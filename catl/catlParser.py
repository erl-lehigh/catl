# Generated from catl.g4 by ANTLR 4.8
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


'''
 Copyright (C) 2018-2020 Cristian Ioan Vasile <cvasile@lehigh.edu>
 Explainable Robotics Lab (ERL), Autonomous and Intelligent Robotics (AIR) Lab,
 Lehigh University
 Hybrid and Networked Systems (HyNeSs) Group, BU Robotics Lab, Boston University
 See license.txt file for license information.
'''


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\27")
        buf.write("\u0083\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3")
        buf.write("\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\5\2(\n")
        buf.write("\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2")
        buf.write("\3\2\3\2\3\2\3\2\7\2;\n\2\f\2\16\2>\13\2\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\5\3I\n\3\3\3\3\3\3\3\5\3N\n\3\3")
        buf.write("\4\3\4\3\4\3\4\3\4\3\4\3\4\5\4W\n\4\3\4\3\4\5\4[\n\4\3")
        buf.write("\4\3\4\5\4_\n\4\3\5\3\5\3\5\3\5\7\5e\n\5\f\5\16\5h\13")
        buf.write("\5\3\5\3\5\3\6\3\6\3\6\3\6\3\6\3\6\3\7\3\7\3\7\3\7\7\7")
        buf.write("v\n\7\f\7\16\7y\13\7\3\7\3\7\3\b\3\b\3\b\3\b\3\b\3\b\3")
        buf.write("\b\2\3\2\t\2\4\6\b\n\f\16\2\3\3\2\25\26\2\u008b\2\'\3")
        buf.write("\2\2\2\4M\3\2\2\2\6^\3\2\2\2\b`\3\2\2\2\nk\3\2\2\2\fq")
        buf.write("\3\2\2\2\16|\3\2\2\2\20\21\b\2\1\2\21\22\7\3\2\2\22\23")
        buf.write("\5\2\2\2\23\24\7\4\2\2\24(\3\2\2\2\25(\5\4\3\2\26(\5\6")
        buf.write("\4\2\27\30\7\17\2\2\30(\5\2\2\t\31\32\7\20\2\2\32\33\7")
        buf.write("\5\2\2\33\34\t\2\2\2\34\35\7\6\2\2\35\36\t\2\2\2\36\37")
        buf.write("\7\7\2\2\37(\5\2\2\b !\7\21\2\2!\"\7\5\2\2\"#\t\2\2\2")
        buf.write("#$\7\6\2\2$%\t\2\2\2%&\7\7\2\2&(\5\2\2\7\'\20\3\2\2\2")
        buf.write("\'\25\3\2\2\2\'\26\3\2\2\2\'\27\3\2\2\2\'\31\3\2\2\2\'")
        buf.write(" \3\2\2\2(<\3\2\2\2)*\f\6\2\2*+\7\16\2\2+;\5\2\2\7,-\f")
        buf.write("\5\2\2-.\7\f\2\2.;\5\2\2\6/\60\f\4\2\2\60\61\7\r\2\2\61")
        buf.write(";\5\2\2\5\62\63\f\3\2\2\63\64\7\22\2\2\64\65\7\5\2\2\65")
        buf.write("\66\t\2\2\2\66\67\7\6\2\2\678\t\2\2\289\7\7\2\29;\5\2")
        buf.write("\2\4:)\3\2\2\2:,\3\2\2\2:/\3\2\2\2:\62\3\2\2\2;>\3\2\2")
        buf.write("\2<:\3\2\2\2<=\3\2\2\2=\3\3\2\2\2><\3\2\2\2?@\7\b\2\2")
        buf.write("@A\7\3\2\2AB\t\2\2\2BC\7\6\2\2CD\7\24\2\2DE\7\6\2\2EH")
        buf.write("\5\b\5\2FG\7\6\2\2GI\5\f\7\2HF\3\2\2\2HI\3\2\2\2IJ\3\2")
        buf.write("\2\2JK\7\4\2\2KN\3\2\2\2LN\7\23\2\2M?\3\2\2\2ML\3\2\2")
        buf.write("\2N\5\3\2\2\2OP\7\t\2\2PQ\7\3\2\2QR\7\24\2\2RV\7\6\2\2")
        buf.write("SW\5\b\5\2TU\7\n\2\2UW\7\13\2\2VS\3\2\2\2VT\3\2\2\2WZ")
        buf.write("\3\2\2\2XY\7\6\2\2Y[\5\f\7\2ZX\3\2\2\2Z[\3\2\2\2[\\\3")
        buf.write("\2\2\2\\_\7\4\2\2]_\7\23\2\2^O\3\2\2\2^]\3\2\2\2_\7\3")
        buf.write("\2\2\2`a\7\n\2\2af\5\n\6\2bc\7\6\2\2ce\5\n\6\2db\3\2\2")
        buf.write("\2eh\3\2\2\2fd\3\2\2\2fg\3\2\2\2gi\3\2\2\2hf\3\2\2\2i")
        buf.write("j\7\13\2\2j\t\3\2\2\2kl\7\3\2\2lm\7\24\2\2mn\7\6\2\2n")
        buf.write("o\7\26\2\2op\7\4\2\2p\13\3\2\2\2qr\7\n\2\2rw\5\16\b\2")
        buf.write("st\7\6\2\2tv\5\16\b\2us\3\2\2\2vy\3\2\2\2wu\3\2\2\2wx")
        buf.write("\3\2\2\2xz\3\2\2\2yw\3\2\2\2z{\7\13\2\2{\r\3\2\2\2|}\7")
        buf.write("\3\2\2}~\7\24\2\2~\177\7\6\2\2\177\u0080\t\2\2\2\u0080")
        buf.write("\u0081\7\4\2\2\u0081\17\3\2\2\2\f\':<HMVZ^fw")
        return buf.getvalue()


class catlParser ( Parser ):

    grammarFileName = "catl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'('", "')'", "'['", "','", "']'", "'T'", 
                     "'L'", "'{'", "'}'", "<INVALID>", "<INVALID>", "'=>'", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'U'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "AND", "OR", "IMPLIES", 
                      "NOT", "EVENT", "ALWAYS", "UNTIL", "BOOLEAN", "VARIABLE", 
                      "RATIONAL", "INT", "WS" ]

    RULE_catlProperty = 0
    RULE_predicate = 1
    RULE_limit = 2
    RULE_capabilities = 3
    RULE_capabilityRequest = 4
    RULE_resources = 5
    RULE_resourceRequest = 6

    ruleNames =  [ "catlProperty", "predicate", "limit", "capabilities", 
                   "capabilityRequest", "resources", "resourceRequest" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    AND=10
    OR=11
    IMPLIES=12
    NOT=13
    EVENT=14
    ALWAYS=15
    UNTIL=16
    BOOLEAN=17
    VARIABLE=18
    RATIONAL=19
    INT=20
    WS=21

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class CatlPropertyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return catlParser.RULE_catlProperty

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class CatlPredicateContext(CatlPropertyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a catlParser.CatlPropertyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def predicate(self):
            return self.getTypedRuleContext(catlParser.PredicateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCatlPredicate" ):
                listener.enterCatlPredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCatlPredicate" ):
                listener.exitCatlPredicate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCatlPredicate" ):
                return visitor.visitCatlPredicate(self)
            else:
                return visitor.visitChildren(self)


    class CatlLimitContext(CatlPropertyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a catlParser.CatlPropertyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def limit(self):
            return self.getTypedRuleContext(catlParser.LimitContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCatlLimit" ):
                listener.enterCatlLimit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCatlLimit" ):
                listener.exitCatlLimit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCatlLimit" ):
                return visitor.visitCatlLimit(self)
            else:
                return visitor.visitChildren(self)


    class FormulaContext(CatlPropertyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a catlParser.CatlPropertyContext
            super().__init__(parser)
            self.left = None # CatlPropertyContext
            self.op = None # Token
            self.child = None # CatlPropertyContext
            self.low = None # Token
            self.high = None # Token
            self.right = None # CatlPropertyContext
            self.copyFrom(ctx)

        def NOT(self):
            return self.getToken(catlParser.NOT, 0)
        def catlProperty(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(catlParser.CatlPropertyContext)
            else:
                return self.getTypedRuleContext(catlParser.CatlPropertyContext,i)

        def EVENT(self):
            return self.getToken(catlParser.EVENT, 0)
        def RATIONAL(self, i:int=None):
            if i is None:
                return self.getTokens(catlParser.RATIONAL)
            else:
                return self.getToken(catlParser.RATIONAL, i)
        def INT(self, i:int=None):
            if i is None:
                return self.getTokens(catlParser.INT)
            else:
                return self.getToken(catlParser.INT, i)
        def ALWAYS(self):
            return self.getToken(catlParser.ALWAYS, 0)
        def IMPLIES(self):
            return self.getToken(catlParser.IMPLIES, 0)
        def AND(self):
            return self.getToken(catlParser.AND, 0)
        def OR(self):
            return self.getToken(catlParser.OR, 0)
        def UNTIL(self):
            return self.getToken(catlParser.UNTIL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormula" ):
                listener.enterFormula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormula" ):
                listener.exitFormula(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFormula" ):
                return visitor.visitFormula(self)
            else:
                return visitor.visitChildren(self)


    class ParpropContext(CatlPropertyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a catlParser.CatlPropertyContext
            super().__init__(parser)
            self.child = None # CatlPropertyContext
            self.copyFrom(ctx)

        def catlProperty(self):
            return self.getTypedRuleContext(catlParser.CatlPropertyContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParprop" ):
                listener.enterParprop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParprop" ):
                listener.exitParprop(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParprop" ):
                return visitor.visitParprop(self)
            else:
                return visitor.visitChildren(self)



    def catlProperty(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = catlParser.CatlPropertyContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 0
        self.enterRecursionRule(localctx, 0, self.RULE_catlProperty, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 37
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                localctx = catlParser.ParpropContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 15
                self.match(catlParser.T__0)
                self.state = 16
                localctx.child = self.catlProperty(0)
                self.state = 17
                self.match(catlParser.T__1)
                pass

            elif la_ == 2:
                localctx = catlParser.CatlPredicateContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 19
                self.predicate()
                pass

            elif la_ == 3:
                localctx = catlParser.CatlLimitContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 20
                self.limit()
                pass

            elif la_ == 4:
                localctx = catlParser.FormulaContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 21
                localctx.op = self.match(catlParser.NOT)
                self.state = 22
                localctx.child = self.catlProperty(7)
                pass

            elif la_ == 5:
                localctx = catlParser.FormulaContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 23
                localctx.op = self.match(catlParser.EVENT)
                self.state = 24
                self.match(catlParser.T__2)
                self.state = 25
                localctx.low = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==catlParser.RATIONAL or _la==catlParser.INT):
                    localctx.low = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 26
                self.match(catlParser.T__3)
                self.state = 27
                localctx.high = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==catlParser.RATIONAL or _la==catlParser.INT):
                    localctx.high = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 28
                self.match(catlParser.T__4)
                self.state = 29
                localctx.child = self.catlProperty(6)
                pass

            elif la_ == 6:
                localctx = catlParser.FormulaContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 30
                localctx.op = self.match(catlParser.ALWAYS)
                self.state = 31
                self.match(catlParser.T__2)
                self.state = 32
                localctx.low = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==catlParser.RATIONAL or _la==catlParser.INT):
                    localctx.low = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 33
                self.match(catlParser.T__3)
                self.state = 34
                localctx.high = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==catlParser.RATIONAL or _la==catlParser.INT):
                    localctx.high = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 35
                self.match(catlParser.T__4)
                self.state = 36
                localctx.child = self.catlProperty(5)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 58
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,2,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 56
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
                    if la_ == 1:
                        localctx = catlParser.FormulaContext(self, catlParser.CatlPropertyContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_catlProperty)
                        self.state = 39
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 40
                        localctx.op = self.match(catlParser.IMPLIES)
                        self.state = 41
                        localctx.right = self.catlProperty(5)
                        pass

                    elif la_ == 2:
                        localctx = catlParser.FormulaContext(self, catlParser.CatlPropertyContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_catlProperty)
                        self.state = 42
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 43
                        localctx.op = self.match(catlParser.AND)
                        self.state = 44
                        localctx.right = self.catlProperty(4)
                        pass

                    elif la_ == 3:
                        localctx = catlParser.FormulaContext(self, catlParser.CatlPropertyContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_catlProperty)
                        self.state = 45
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 46
                        localctx.op = self.match(catlParser.OR)
                        self.state = 47
                        localctx.right = self.catlProperty(3)
                        pass

                    elif la_ == 4:
                        localctx = catlParser.FormulaContext(self, catlParser.CatlPropertyContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_catlProperty)
                        self.state = 48
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 49
                        localctx.op = self.match(catlParser.UNTIL)
                        self.state = 50
                        self.match(catlParser.T__2)
                        self.state = 51
                        localctx.low = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==catlParser.RATIONAL or _la==catlParser.INT):
                            localctx.low = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 52
                        self.match(catlParser.T__3)
                        self.state = 53
                        localctx.high = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==catlParser.RATIONAL or _la==catlParser.INT):
                            localctx.high = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 54
                        self.match(catlParser.T__4)
                        self.state = 55
                        localctx.right = self.catlProperty(2)
                        pass

             
                self.state = 60
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,2,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class PredicateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.op = None # Token
            self.duration = None # Token
            self.proposition = None # Token

        def capabilities(self):
            return self.getTypedRuleContext(catlParser.CapabilitiesContext,0)


        def VARIABLE(self):
            return self.getToken(catlParser.VARIABLE, 0)

        def RATIONAL(self):
            return self.getToken(catlParser.RATIONAL, 0)

        def INT(self):
            return self.getToken(catlParser.INT, 0)

        def resources(self):
            return self.getTypedRuleContext(catlParser.ResourcesContext,0)


        def BOOLEAN(self):
            return self.getToken(catlParser.BOOLEAN, 0)

        def getRuleIndex(self):
            return catlParser.RULE_predicate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicate" ):
                listener.enterPredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicate" ):
                listener.exitPredicate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredicate" ):
                return visitor.visitPredicate(self)
            else:
                return visitor.visitChildren(self)




    def predicate(self):

        localctx = catlParser.PredicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_predicate)
        self._la = 0 # Token type
        try:
            self.state = 75
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [catlParser.T__5]:
                self.enterOuterAlt(localctx, 1)
                self.state = 61
                localctx.op = self.match(catlParser.T__5)
                self.state = 62
                self.match(catlParser.T__0)
                self.state = 63
                localctx.duration = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==catlParser.RATIONAL or _la==catlParser.INT):
                    localctx.duration = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 64
                self.match(catlParser.T__3)
                self.state = 65
                localctx.proposition = self.match(catlParser.VARIABLE)
                self.state = 66
                self.match(catlParser.T__3)
                self.state = 67
                self.capabilities()
                self.state = 70
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==catlParser.T__3:
                    self.state = 68
                    self.match(catlParser.T__3)
                    self.state = 69
                    self.resources()


                self.state = 72
                self.match(catlParser.T__1)
                pass
            elif token in [catlParser.BOOLEAN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 74
                localctx.op = self.match(catlParser.BOOLEAN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LimitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.op = None # Token
            self.proposition = None # Token

        def VARIABLE(self):
            return self.getToken(catlParser.VARIABLE, 0)

        def capabilities(self):
            return self.getTypedRuleContext(catlParser.CapabilitiesContext,0)


        def resources(self):
            return self.getTypedRuleContext(catlParser.ResourcesContext,0)


        def BOOLEAN(self):
            return self.getToken(catlParser.BOOLEAN, 0)

        def getRuleIndex(self):
            return catlParser.RULE_limit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLimit" ):
                listener.enterLimit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLimit" ):
                listener.exitLimit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLimit" ):
                return visitor.visitLimit(self)
            else:
                return visitor.visitChildren(self)




    def limit(self):

        localctx = catlParser.LimitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_limit)
        self._la = 0 # Token type
        try:
            self.state = 92
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [catlParser.T__6]:
                self.enterOuterAlt(localctx, 1)
                self.state = 77
                localctx.op = self.match(catlParser.T__6)
                self.state = 78
                self.match(catlParser.T__0)
                self.state = 79
                localctx.proposition = self.match(catlParser.VARIABLE)
                self.state = 80
                self.match(catlParser.T__3)
                self.state = 84
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
                if la_ == 1:
                    self.state = 81
                    self.capabilities()
                    pass

                elif la_ == 2:
                    self.state = 82
                    self.match(catlParser.T__7)
                    self.state = 83
                    self.match(catlParser.T__8)
                    pass


                self.state = 88
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==catlParser.T__3:
                    self.state = 86
                    self.match(catlParser.T__3)
                    self.state = 87
                    self.resources()


                self.state = 90
                self.match(catlParser.T__1)
                pass
            elif token in [catlParser.BOOLEAN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 91
                localctx.op = self.match(catlParser.BOOLEAN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CapabilitiesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def capabilityRequest(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(catlParser.CapabilityRequestContext)
            else:
                return self.getTypedRuleContext(catlParser.CapabilityRequestContext,i)


        def getRuleIndex(self):
            return catlParser.RULE_capabilities

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCapabilities" ):
                listener.enterCapabilities(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCapabilities" ):
                listener.exitCapabilities(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCapabilities" ):
                return visitor.visitCapabilities(self)
            else:
                return visitor.visitChildren(self)




    def capabilities(self):

        localctx = catlParser.CapabilitiesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_capabilities)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 94
            self.match(catlParser.T__7)
            self.state = 95
            self.capabilityRequest()
            self.state = 100
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==catlParser.T__3:
                self.state = 96
                self.match(catlParser.T__3)
                self.state = 97
                self.capabilityRequest()
                self.state = 102
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 103
            self.match(catlParser.T__8)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CapabilityRequestContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.cap = None # Token
            self.count = None # Token

        def VARIABLE(self):
            return self.getToken(catlParser.VARIABLE, 0)

        def INT(self):
            return self.getToken(catlParser.INT, 0)

        def getRuleIndex(self):
            return catlParser.RULE_capabilityRequest

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCapabilityRequest" ):
                listener.enterCapabilityRequest(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCapabilityRequest" ):
                listener.exitCapabilityRequest(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCapabilityRequest" ):
                return visitor.visitCapabilityRequest(self)
            else:
                return visitor.visitChildren(self)




    def capabilityRequest(self):

        localctx = catlParser.CapabilityRequestContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_capabilityRequest)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 105
            self.match(catlParser.T__0)
            self.state = 106
            localctx.cap = self.match(catlParser.VARIABLE)
            self.state = 107
            self.match(catlParser.T__3)
            self.state = 108
            localctx.count = self.match(catlParser.INT)
            self.state = 109
            self.match(catlParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResourcesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def resourceRequest(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(catlParser.ResourceRequestContext)
            else:
                return self.getTypedRuleContext(catlParser.ResourceRequestContext,i)


        def getRuleIndex(self):
            return catlParser.RULE_resources

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResources" ):
                listener.enterResources(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResources" ):
                listener.exitResources(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResources" ):
                return visitor.visitResources(self)
            else:
                return visitor.visitChildren(self)




    def resources(self):

        localctx = catlParser.ResourcesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_resources)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 111
            self.match(catlParser.T__7)
            self.state = 112
            self.resourceRequest()
            self.state = 117
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==catlParser.T__3:
                self.state = 113
                self.match(catlParser.T__3)
                self.state = 114
                self.resourceRequest()
                self.state = 119
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 120
            self.match(catlParser.T__8)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResourceRequestContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.res = None # Token
            self.quantity = None # Token

        def VARIABLE(self):
            return self.getToken(catlParser.VARIABLE, 0)

        def RATIONAL(self):
            return self.getToken(catlParser.RATIONAL, 0)

        def INT(self):
            return self.getToken(catlParser.INT, 0)

        def getRuleIndex(self):
            return catlParser.RULE_resourceRequest

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResourceRequest" ):
                listener.enterResourceRequest(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResourceRequest" ):
                listener.exitResourceRequest(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResourceRequest" ):
                return visitor.visitResourceRequest(self)
            else:
                return visitor.visitChildren(self)




    def resourceRequest(self):

        localctx = catlParser.ResourceRequestContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_resourceRequest)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 122
            self.match(catlParser.T__0)
            self.state = 123
            localctx.res = self.match(catlParser.VARIABLE)
            self.state = 124
            self.match(catlParser.T__3)
            self.state = 125
            localctx.quantity = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==catlParser.RATIONAL or _la==catlParser.INT):
                localctx.quantity = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 126
            self.match(catlParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[0] = self.catlProperty_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def catlProperty_sempred(self, localctx:CatlPropertyContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 1)
         




